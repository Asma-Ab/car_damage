import streamlit as st
import numpy as np
import os
from PIL import Image
from tensorflow.keras.models import load_model
from tensorflow.keras.optimizers import Adam
import subprocess
import uuid
import glob
import shutil
from ultralytics import YOLO
# Set page title and favicon
st.set_page_config(
    page_title="Car Damage Assessment App",
    page_icon="ðŸš—",  # Customized icon representing cars
    layout="wide",
    initial_sidebar_state="expanded",  # Set to "collapsed" if you prefer a collapsed sidebar initially
)

# Custom CSS for styling
st.markdown("""
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #f4f4f4;
            color: #333333;
        }
        .sidebar .sidebar-content {
            background-color: #2E2E2E;
            color: #FFFFFF;
        }
        .widget-content {
            background-color: #FFFFFF;
            border-radius: 10px;
            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
    </style>
""", unsafe_allow_html=True)

st.title("Car Damage Assessment App")

@st.cache_resource
def load_aiornot_model():
    file_path = os.path.abspath("fake_real_inception.h5")
    model = load_model(file_path, compile=False)
    optimizer = Adam(learning_rate=0.001)
    model.compile(optimizer=optimizer, loss='binary_crossentropy', metrics=['accuracy'])
    return model

@st.cache_resource
def load_severity_model():
    file_path = os.path.abspath("severity_inception.h5")
    model = load_model(file_path, compile=False)
    optimizer = Adam(learning_rate=0.001)
    model.compile(optimizer=optimizer, loss='categorical_crossentropy', metrics=['accuracy'])
    return model

@st.cache_resource
def estimate_damage_cost(severity, damage_types):
    # Define cost multipliers for each severity and damage type
    severity_multiplier = {
        "Minor Damage": {"crack": 50, "dent": 30, "glass shatter": 40, "lamp broken": 50, "scratch": 20, "tire flat": 30},
        "Moderate Damage": {"crack": 75, "dent": 60, "glass shatter": 90, "lamp broken": 120, "scratch": 50, "tire flat": 70},
        "Severe Damage": {"crack": 120, "dent": 100, "glass shatter": 150, "lamp broken": 200, "scratch": 80, "tire flat": 120},
    }

    # Get the severity-specific cost multiplier
    severity_multiplier_dict = severity_multiplier.get(severity, {})
    
    # Calculate the total cost based on severity and damage types
    total_cost = sum(severity_multiplier_dict.get(damage, 0) for damage in damage_types)

    return total_cost



st.sidebar.markdown("## Project description :")
st.sidebar.markdown("### Project Overview:")
st.sidebar.write(
    """
    Explore the Car Damage Assessment App, an intelligent solution crafted for in-depth analysis of vehicle images. Developed by Asma Abidalli and Sarra Hammami, this application seamlessly evaluates different facets of car damage, offering insights into authenticity, severity, and types of damages.

    ### Key Features:

    - **Real or AI-generated Recognition:**
      Quickly identify if an image is an authentic photograph or generated by artificial intelligence.

    - **Damage Severity Prediction:**
      Assess the severity of damage, categorizing it as Minor, Moderate, or Severe.

    - **Damaged Parts Identification (YOLO):**
      Utilize YOLO (You Only Look Once) for precise detection and highlighting of damaged components.

    - **Damage Type Prediction (YOLO):**
      Leverage YOLO for segmenting and identifying specific types of damage in the image.

    - **Damage Repair Cost:**
      Estimate the repair cost according to the damage severity.

    ### How to Use:

    1. **Upload Your Image:**
       Choose a car image in JPG, PNG, JPEG, or WebP format using the "Upload Your Image" section.

    2. **Instant Results Display:**
       Real-time predictions for Real or AI-generated recognition, Damage Severity, Damaged Parts, and Damage Type are displayed immediately after image upload.

   
    """
)

st.sidebar.markdown("""---""")
st.sidebar.write('Created by Asma Abidalli & Sarra Hammami')

upload_columns = st.columns([2, 1])
file_upload = upload_columns[0].expander(label='Upload Your Image')
uploaded_image = file_upload.file_uploader("Choose an image...", type=["jpg", "png", "jpeg", 'webp'], key="file_uploader")

if uploaded_image is not None:
    # Display the uploaded image
    image = Image.open(uploaded_image)
    upload_columns[1].image(image, caption="Uploaded Image", use_column_width=True)

    # **Real or AI-generated Prediction:**
    with st.spinner("Predicting Real or AI-generated image..."):
        img_aiornot = image.resize((224, 224))
        img_aiornot = np.array(img_aiornot)
        img_aiornot = img_aiornot / 255.0
        img_aiornot = np.expand_dims(img_aiornot, axis=0)
        model_aiornot = load_aiornot_model()
        prediction_aiornot = model_aiornot.predict(img_aiornot)
        result_aiornot = "AI-Generated Image" if prediction_aiornot < 0.7 else "Real Image"
        st.markdown(f"<h2>Real or AI-generated Prediction:</h2><p style='font-size:20px;'>{result_aiornot}</p>", unsafe_allow_html=True)

    # **Damage Severity Prediction:**
    with st.spinner("Predicting Damage Severity..."):
        img_severity = image.resize((224, 224))
        img_severity = np.array(img_severity)
        img_severity = img_severity / 255.0
        img_severity = np.expand_dims(img_severity, axis=0)
        model_severity = load_severity_model()
        prediction_severity = model_severity.predict(img_severity)
        damage_classes = ["Minor Damage", "Moderate Damage", "Severe Damage"]
        predicted_class_severity = damage_classes[np.argmax(prediction_severity)]
        confidence_severity = prediction_severity[0][np.argmax(prediction_severity)]
        st.markdown(f"<h2>Damage Severity Prediction:</h2><p style='font-size:20px;'>{predicted_class_severity}</p>", unsafe_allow_html=True)

    # **Damage Type Prediction with YOLO:**
    st.markdown(f"<h2>Damage Type Detection:</h2>", unsafe_allow_html=True)
    temp_dir = "temp_images"
    temp_image_path_type = os.path.join(temp_dir, f"uploaded_image_{uuid.uuid4()}.jpg")
    image.save(temp_image_path_type, format='JPEG')
    model = YOLO("type_best.pt")
    command_type = f"yolo task=segment mode=predict model=type_best.pt conf=0.25 source={temp_image_path_type}"
    yolo_process_type = subprocess.run(command_type, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    if yolo_process_type.returncode == 0:
        latest_subdir_type = max(glob.glob(os.path.join("runs", "segment", "predict*")), key=os.path.getctime)
        result_image_path_type = os.path.join(latest_subdir_type, f"{os.path.basename(temp_image_path_type).split('.')[0]}.jpg")
        result_image_type = Image.open(result_image_path_type)
        resized_image_type = result_image_type.resize((600, 400))
        st.image(resized_image_type, caption="YOLO Damage Type Result")
            # Delete temporary files and folder
                # Extract predicted classes using provided code
        res = model.predict(temp_image_path_type)
        clist= res[0].boxes.cls
        cls = set()
        for cno in clist:
            cls.add(model.names[int(cno)])

        predicted_classes_type = list(cls)
        print(predicted_classes_type)
        os.remove(temp_image_path_type)
        shutil.rmtree(latest_subdir_type, ignore_errors=True)
    else:
        st.error(f"YOLO process failed with error:\n{yolo_process_type.stderr.decode('utf-8')}")


    # **Damaged Parts Prediction with YOLO:**
    predicted_classes = []
    st.markdown(f"<h2>Damaged parts Detection:</h2>", unsafe_allow_html=True)
    temp_dir = "temp_images"
    os.makedirs(temp_dir, exist_ok=True)
    temp_image_path_parts = os.path.join(temp_dir, f"uploaded_image_{uuid.uuid4()}.jpg")
    image.save(temp_image_path_parts, format='JPEG')

    # Instantiate the YOLO model
    model = YOLO("part_best.pt")

    command_parts = f"yolo task=detect mode=predict model=part_best.pt conf=0.25 source={temp_image_path_parts}"
    yolo_process_parts = subprocess.run(command_parts, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    if yolo_process_parts.returncode == 0:
        latest_subdir_parts = max(glob.glob(os.path.join("runs", "detect", "predict*")), key=os.path.getctime)
        result_image_path_parts = os.path.join(latest_subdir_parts, f"{os.path.basename(temp_image_path_parts).split('.')[0]}.jpg")
        result_image_parts = Image.open(result_image_path_parts)
        resized_image_part = result_image_parts.resize((600, 400))
        st.image(resized_image_part, caption="YOLO Damaged Parts Result")

        # Extract predicted classes using provided code
        res = model.predict(temp_image_path_parts)
        clist= res[0].boxes.cls
        cls = set()
        for cno in clist:
            cls.add(model.names[int(cno)])

        predicted_classes_part = list(cls)
        print(predicted_classes_part)
        os.remove(temp_image_path_parts)
        shutil.rmtree(latest_subdir_parts, ignore_errors=True)
    else:
        st.error(f"YOLO process failed with error:\n{yolo_process_parts.stderr.decode('utf-8')}")

    st.markdown(f"<h2>Damage Cost Estimation:</h2>", unsafe_allow_html=True)
    # **Damage Repair Cost:**
    # Use the predicted severity and type for cost estimation
    estimated_cost = estimate_damage_cost(predicted_class_severity,predicted_classes_type)
    st.write(f"Estimated Damage Cost: ${estimated_cost}")